<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=7.0.1">


  <link rel="mask-icon" href="/favicon.ico?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="转载自：https://linux.cn/article-3251-1.html 内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核">
<meta name="keywords" content="Linux,Kernel">
<meta property="og:type" content="article">
<meta property="og:title" content="编写属于你的第一个Linux内核模块">
<meta property="og:url" content="https://www.huberylee.com/2015/10/10/编写属于你的第一个Linux内核模块/index.html">
<meta property="og:site_name" content="HuberyLee">
<meta property="og:description" content="转载自：https://linux.cn/article-3251-1.html 内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.huberylee.com/images/2015-10-10/img-1.jpg">
<meta property="og:updated_time" content="2018-01-07T02:54:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="编写属于你的第一个Linux内核模块">
<meta name="twitter:description" content="转载自：https://linux.cn/article-3251-1.html 内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核">
<meta name="twitter:image" content="https://www.huberylee.com/images/2015-10-10/img-1.jpg">






  <link rel="canonical" href="https://www.huberylee.com/2015/10/10/编写属于你的第一个Linux内核模块/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>编写属于你的第一个Linux内核模块 | HuberyLee</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuberyLee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    

    <a href="/archives/" rel="section">归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-photography">

    
    
    

    

    <a href="https://huberylee.tuchong.com" rel="noopener" target="_blank">摄影</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    

    <a href="/about/" rel="section">关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.huberylee.com/2015/10/10/编写属于你的第一个Linux内核模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuberyLee">
      <meta itemprop="description" content="玩得酷，靠得住，有梦想，爱学习的实力派！">
      <meta itemprop="image" content="/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuberyLee">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">编写属于你的第一个Linux内核模块

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2015-10-10 16:46:14" itemprop="dateCreated datePublished" datetime="2015-10-10T16:46:14+08:00">2015-10-10</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/" itemprop="url" rel="index"><span itemprop="name">Kernel</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2015/10/10/编写属于你的第一个Linux内核模块/" class="leancloud_visitors" data-flag-title="编写属于你的第一个Linux内核模块">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>转载自：<a href="https://linux.cn/article-3251-1.html" target="_blank" rel="noopener">https://linux.cn/article-3251-1.html</a></p>
<p>内核编程常常看起来像是黑魔法，而在亚瑟 C 克拉克的眼中，它八成就是了。Linux内核和它的用户空间是大不相同的：抛开漫不经心，你必须小心翼翼，因为你编程中的一个bug就会影响到整个系统。浮点运算做起来可不容易，堆栈固定而狭小，而你写的代码总是异步的，因此你需要想想并发会导致什么。而除了所有这一切之外，Linux内核只是一个很大的、很复杂的C程序，它对每个人开放，任何人都去读它、学习它并改进它，而你也可以是其中之一。</p>
<a id="more"></a>
<p><img src="/images/2015-10-10/img-1.jpg" alt></p>
<p>学习内核编程的最简单的方式也许就是写个内核模块：一段可以动态加载进内核的代码。模块所能做的事是有限的——例如，他们不能在类似进程描述符这样的公共数据结构中增减字段（LCTT译注：可能会破坏整个内核及系统的功能）。但是，在其它方面，他们是成熟的内核级的代码，可以在需要时随时编译进内核（这样就可以摒弃所有的限制了）。完全可以在Linux源代码树以外来开发并编译一个模块（这并不奇怪，它称为树外开发），如果你只是想稍微玩玩，而并不想提交修改以包含到主线内核中去，这样的方式是很方便的。</p>
<p>在本教程中，我们将开发一个简单的内核模块用以创建一个<code>/dev/reverse</code>设备。写入该设备的字符串将以相反字序的方式读回（“Hello World”读成“World Hello”）。这是一个很受欢迎的程序员面试难题，当你利用自己的能力在内核级别实现这个功能时，可以使你得到一些加分。在开始前，有一句忠告：你的模块中的一个bug就会导致系统崩溃（虽然可能性不大，但还是有可能的）和数据丢失。在开始前，请确保你已经将重要数据备份，或者，采用一种更好的方式，在虚拟机中进行试验。</p>
<h2 id="尽可能不要用root身份"><a href="#尽可能不要用root身份" class="headerlink" title="尽可能不要用root身份"></a>尽可能不要用root身份</h2><p>默认情况下，<code>/dev/reverse</code>只有root可以使用，因此你只能使用sudo来运行你的测试程序。要解决该限制，可以创建一个包含以下内容的<code>/lib/udev/rules.d/99-reverse.rules</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSYSTEM==<span class="string">"misc"</span>, KERNEL==<span class="string">"reverse"</span>, MODE=<span class="string">"0666"</span></span><br></pre></td></tr></table></figure>
<p>别忘了重新插入模块。让非root用户访问设备节点往往不是一个好主意，但是在开发其间却是十分有用的。这并不是说以root身份运行二进制测试文件也不是个好主意。</p>
<h3 id="模块的构造"><a href="#模块的构造" class="headerlink" title="模块的构造"></a>模块的构造</h3><p>由于大多数的Linux内核模块是用C写的（除了底层的特定于体系结构的部分），所以推荐你将你的模块以单一文件形式保存（例如，<code>reverse.c</code>）。我们已经把完整的源代码放在<a href="https://github.com/vsinitsyn/reverse" target="_blank" rel="noopener">GitHub</a>上——这里我们将看其中的一些片段。开始时，我们先要包含一些常见的文件头，并用预定义的宏来描述模块：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Valentine Sinitsyn &lt;valentine.sinitsyn@gmail.com&gt;"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"In-kernel phrase reverser"</span>);</span><br></pre></td></tr></table></figure>
<p>这里一切都直接明了，除了<code>MODULE_LICENSE()</code>：它不仅仅是一个标记。内核坚定地支持GPL兼容代码，因此如果你把许可证设置为其它非GPL兼容的（如，“Proprietary”[专利]），某些特定的内核功能将在你的模块中不可用。</p>
<h2 id="什么时候不该写内核模块"><a href="#什么时候不该写内核模块" class="headerlink" title="什么时候不该写内核模块"></a>什么时候不该写内核模块</h2><p>内核编程很有趣，但是在现实项目中写（尤其是调试）内核代码要求特定的技巧。通常来讲，在没有其它方式可以解决你的问题时，你才应该在内核级别解决它。以下情形中，可能你在用户空间中解决它更好：</p>
<ul>
<li>你要开发一个USB驱动 —— 请查看libusb。</li>
<li>你要开发一个文件系统 —— 试试FUSE。</li>
<li>你在扩展Netfilter —— 那么<code>libnetfilter_queue</code>对你有所帮助。</li>
</ul>
<p>通常，内核里面代码的性能会更好，但是对于许多项目而言，这点性能丢失并不严重。</p>
<p>由于内核编程总是异步的，没有一个<code>main()</code>函数来让Linux顺序执行你的模块。取而代之的是，你要为各种事件提供回调函数，像这个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">reverse_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"reverse device has been registered\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">reverse_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">"reverse device has been unregistered\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(reverse_init);</span><br><span class="line">module_exit(reverse_exit);</span><br></pre></td></tr></table></figure>
<p>这里，我们定义的函数被称为模块的插入和删除。只有第一个的插入函数是必要的。目前，它们只是打印消息到内核环缓冲区（可以在用户空间通过<code>dmesg</code>命令访问）；<code>KERN_INFO</code>是日志级别（注意，没有逗号）。<code>__init</code>和<code>__exit</code>是属性 —— 联结到函数（或者变量）的元数据片。属性在用户空间的C代码中是很罕见的，但是内核中却很普遍。所有标记为<code>__init</code>的，会在初始化后释放内存以供重用（还记得那条过去内核的那条“Freeing unused kernel memory…[释放未使用的内核内存……]”信息吗？）。<code>__exit</code>表明，当代码被静态构建进内核时，该函数可以安全地优化了，不需要清理收尾。最后，<code>module_init()</code>和<code>module_exit()</code>这两个宏将<code>reverse_init()</code>和<code>reverse_exit()</code>函数设置成为我们模块的生命周期回调函数。实际的函数名称并不重要，你可以称它们为<code>init()</code>和<code>exit()</code>，或者<code>start()</code>和<code>stop()</code>，你想叫什么就叫什么吧。他们都是静态声明，你在外部模块是看不到的。事实上，内核中的任何函数都是不可见的，除非明确地被导出。然而，在内核程序员中，给你的函数加上模块名前缀是约定俗成的。</p>
<p>这些都是些基本概念 - 让我们来做更多有趣的事情吧。模块可以接收参数，就像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe foo bar=1</span></span><br></pre></td></tr></table></figure>
<p><code>modinfo</code>命令显示了模块接受的所有参数，而这些也可以在<code>/sys/module//parameters</code>下作为文件使用。我们的模块需要一个缓冲区来存储参数 —— 让我们把这大小设置为用户可配置。在<code>MODULE_DESCRIPTION()</code>下添加如下三行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> buffer_size = <span class="number">8192</span>;</span><br><span class="line">module_param(buffer_size, ulong, (S_IRUSR | S_IRGRP | S_IROTH));</span><br><span class="line">MODULE_PARM_DESC(buffer_size, <span class="string">"Internal buffer size"</span>);</span><br></pre></td></tr></table></figure>
<p>这儿，我们定义了一个变量来存储该值，封装成一个参数，并通过<code>sysfs</code>来让所有人可读。这个参数的描述（最后一行）出现在<code>modinfo</code>的输出中。</p>
<p>由于用户可以直接设置<code>buffer_size</code>，我们需要在<code>reverse_init()</code>来清除无效取值。你总该检查来自内核之外的数据 —— 如果你不这么做，你就是将自己置身于内核异常或安全漏洞之中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">reverse_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!buffer_size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    printk(KERN_INFO</span><br><span class="line">        <span class="string">"reverse device has been registered, buffer size is %lu bytes\n"</span>,</span><br><span class="line">        buffer_size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来自模块初始化函数的非0返回值意味着模块执行失败。</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>但你开发模块时，Linux内核就是你所需一切的源头。然而，它相当大，你可能在查找你所要的内容时会有困难。幸运的是，在庞大的代码库面前，有许多工具使这个过程变得简单。首先，是Cscope —— 在终端中运行的一个比较经典的工具。你所要做的，就是在内核源代码的顶级目录中运行<code>make cscope &amp;&amp; cscope</code>。Cscope和Vim以及Emacs整合得很好，因此你可以在你最喜爱的编辑器中使用它。</p>
<p>如果基于终端的工具不是你的最爱，那么就访问<a href="http://lxr.free-electrons.com" target="_blank" rel="noopener">http://lxr.free-electrons.com</a>吧。它是一个基于web的内核导航工具，即使它的功能没有Cscope来得多（例如，你不能方便地找到函数的用法），但它仍然提供了足够多的快速查询功能。</p>
<p>现在是时候来编译模块了。你需要你正在运行的内核版本头文件（<code>linux-headers</code>，或者等同的软件包）和<code>build-essential</code>（或者类似的包）。接下来，该创建一个标准的<code>Makefile</code>模板：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m += reverse.o</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>现在，调用make来构建你的第一个模块。如果你输入的都正确，在当前目录内会找到<code>reverse.ko</code>文件。使用<code>sudo insmod reverse.ko</code>插入内核模块，然后运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | tail -1</span><br><span class="line">[ 5905.042081] reverse device has been registered, buffer size is 8192 bytes</span><br></pre></td></tr></table></figure>
<p>恭喜了！然而，目前这一行还只是假象而已 —— 还没有设备节点呢。让我们来搞定它。</p>
<h3 id="混杂设备"><a href="#混杂设备" class="headerlink" title="混杂设备"></a>混杂设备</h3><p>在Linux中，有一种特殊的字符设备类型，叫做“混杂设备”（或者简称为“misc”）。它是专为单一接入点的小型设备驱动而设计的，而这正是我们所需要的。所有混杂设备共享同一个主设备号（10），因此一个驱动(<code>drivers/char/misc.c</code>）就可以查看它们所有设备了，而这些设备用次设备号来区分。从其他意义来说，它们只是普通字符设备。</p>
<p>要为该设备注册一个次设备号（以及一个接入点），你需要声明<code>struct misc_device</code>，填上所有字段（注意语法），然后使用指向该结构的指针作为参数来调用<code>misc_register()</code>。为此，你也需要包含<code>linux/miscdevice.h</code>头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">reverse_misc_device</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">"reverse"</span>,</span><br><span class="line">    .fops = &amp;reverse_fops</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">reverse_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    misc_register(&amp;reverse_misc_device);</span><br><span class="line">    printk(KERN_INFO ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿，我们为名为“reverse”的设备请求一个第一个可用的（动态的）次设备号；省略号表明我们之前已经见过的省略的代码。别忘了在模块卸下后注销掉该设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">reverse_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    misc_deregister(&amp;reverse_misc_device);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>‘fops’字段存储了一个指针，指向一个<code>file_operations</code>结构（在<code>Linux/fs.h</code>中声明），而这正是我们模块的接入点。<code>reverse_fops</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">reverse_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = reverse_open,</span><br><span class="line">    ...</span><br><span class="line">    .llseek = noop_llseek</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，<code>reverse_fops</code>包含了一系列回调函数（也称之为方法），当用户空间代码打开一个设备，读写或者关闭文件描述符时，就会执行。如果你要忽略这些回调，可以指定一个明确的回调函数来替代。这就是为什么我们将llseek设置为<code>noop_llseek()</code>，（顾名思义）它什么都不干。这个默认实现改变了一个文件指针，而且我们现在并不需要我们的设备可以寻址（这是今天留给你们的家庭作业）。</p>
<h3 id="关闭和打开"><a href="#关闭和打开" class="headerlink" title="关闭和打开"></a>关闭和打开</h3><p>让我们来实现该方法。我们将给每个打开的文件描述符分配一个新的缓冲区，并在它关闭时释放。这实际上并不安全：如果一个用户空间应用程序泄漏了描述符（也许是故意的），它就会霸占RAM，并导致系统不可用。在现实世界中，你总得考虑到这些可能性。但在本教程中，这种方法不要紧。</p>
<p>我们需要一个结构函数来描述缓冲区。内核提供了许多常规的数据结构：链接列表（双联的），哈希表，树等等之类。不过，缓冲区常常从头设计。我们将调用我们的“struct buffer”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data, *end, *read_ptr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>data是该缓冲区存储的一个指向字符串的指针，而end指向字符串结尾后的第一个字节。<code>read_ptr</code>是<code>read()</code>开始读取数据的地方。缓冲区的size是为了保证完整性而存储的 —— 目前，我们还没有使用该区域。你不能假设使用你结构体的用户会正确地初始化所有这些东西，所以最好在函数中封装缓冲区的分配和收回。它们通常命名为<code>buffer_alloc()</code>和<code>buffer_free()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct buffer <span class="title">buffer_alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span> </span>&#123; <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span>;</span> buf = kzalloc(<span class="keyword">sizeof</span>(buf), GFP_KERNEL); <span class="keyword">if</span> (unlikely(!buf)) <span class="keyword">goto</span> out; ... out: <span class="keyword">return</span> buf; &#125;</span><br></pre></td></tr></table></figure>
<p>内核内存使用<code>kmalloc()</code>来分配，并使用<code>kfree()</code>来释放；<code>kzalloc()</code>的风格是将内存设置为全零。不同于标准的<code>malloc()</code>，它的内核对应部分收到的标志指定了第二个参数中请求的内存类型。这里，<code>GFP_KERNEL</code>是说我们需要一个普通的内核内存（不是在DMA或高内存区中）以及如果需要的话函数可以睡眠（重新调度进程）。<code>sizeof(*buf)</code>是一种常见的方式，它用来获取可通过指针访问的结构体的大小。</p>
<p>你应该随时检查<code>kmalloc()</code>的返回值：访问NULL指针将导致内核异常。同时也需要注意<code>unlikely()</code>宏的使用。它（及其相对宏<code>likely()</code>）被广泛用于内核中，用于表明条件几乎总是真的（或假的）。它不会影响到控制流程，但是能帮助现代处理器通过分支预测技术来提升性能。</p>
<p>最后，注意goto语句。它们常常为认为是邪恶的，但是，Linux内核（以及一些其它系统软件）采用它们来实施集中式的函数退出。这样的结果是减少嵌套深度，使代码更具可读性，而且非常像更高级语言中的<code>try-catch</code>区块。</p>
<p>有了<code>buffer_alloc()</code>和<code>buffer_free()</code>，open和close方法就变得很简单了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    file-&gt;private_data = buffer_alloc(buffer_size);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>struct file是一个标准的内核数据结构，用以存储打开的文件的信息，如当前文件位置（<code>file-&gt;f_pos</code>)、标志(<code>file-&gt;f_flags</code>），或者打开模式（<code>file-&gt;f_mode</code>)等。另外一个字段<code>file-&gt;privatedata</code>用于关联文件到一些专有数据，它的类型是void *，而且它在文件拥有者以外，对内核不透明。我们将一个缓冲区存储在那里。</p>
<p>如果缓冲区分配失败，我们通过返回否定值（<code>-ENOMEM</code>）来为调用的用户空间代码标明。一个C库中调用的<code>open(2)</code>系统调用(如 <code>glibc</code>)将会检测这个并适当地设置<code>errno</code> 。</p>
<h3 id="学习如何读和写"><a href="#学习如何读和写" class="headerlink" title="学习如何读和写"></a>学习如何读和写</h3><p>“read”和“write”方法是真正完成工作的地方。当数据写入到缓冲区时，我们放弃之前的内容和反向地存储该字段，不需要任何临时存储。read方法仅仅是从内核缓冲区复制数据到用户空间。但是如果缓冲区还没有数据，<code>revers_eread()</code>会做什么呢？在用户空间中，<code>read()</code>调用会在有可用数据前阻塞它。在内核中，你就必须等待。幸运的是，有一项机制用于处理这种情况，就是‘wait queues’。</p>
<p>想法很简单。如果当前进程需要等待某个事件，它的描述符（<code>struct task_struct</code>存储‘current’信息）被放进非可运行（睡眠中）状态，并添加到一个队列中。然后schedule()就被调用来选择另一个进程运行。生成事件的代码通过使用队列将等待进程放回<code>TASK_RUNNING</code>状态来唤醒它们。调度程序将在以后在某个地方选择它们之一。Linux有多种非可运行状态，最值得注意的是<code>TASK_INTERRUPTIBLE</code>（一个可以通过信号中断的睡眠）和<code>TASK_KILLABLE</code>（一个可被杀死的睡眠中的进程）。所有这些都应该正确处理，并等待队列为你做这些事。</p>
<p>一个用以存储读取等待队列头的天然场所就是结构缓冲区，所以从为它添加<code>wait_queue_headt read\queue</code>字段开始。你也应该包含<code>linux/sched.h</code>头文件。可以使用<code>DECLARE_WAITQUEUE()</code>宏来静态声明一个等待队列。在我们的情况下，需要动态初始化，因此添加下面这行到<code>buffer_alloc()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_waitqueue_head(&amp;buf-&gt;read_queue);</span><br></pre></td></tr></table></figure>
<p>我们等待可用数据；或者等待<code>read_ptr != end</code>条件成立。我们也想要让等待操作可以被中断（如，通过<code>Ctrl+C</code>）。因此，“read”方法应该像这样开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">reverse_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user * out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line">    <span class="keyword">while</span> (buf-&gt;read_ptr == buf-&gt;end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">            result = -EAGAIN;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wait_event_interruptible</span><br><span class="line">        (buf-&gt;read_queue, buf-&gt;read_ptr != buf-&gt;end)) &#123;</span><br><span class="line">            result = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>我们让它循环，直到有可用数据，如果没有则使用<code>wait_event_interruptible()</code>（它是一个宏，不是函数，这就是为什么要通过值的方式给队列传递）来等待。好吧，如果<code>wait_event_interruptible()</code>被中断，它返回一个非0值，这个值代表-ERESTARTSYS。这段代码意味着系统调用应该重新启动。<code>file-&gt;f_flags</code>检查以非阻塞模式打开的文件数：如果没有数据，返回-EAGAIN。</p>
<p>我们不能使用<code>if()</code>来替代<code>while()</code>，因为可能有许多进程正等待数据。当write方法唤醒它们时，调度程序以不可预知的方式选择一个来运行，因此，在这段代码有机会执行的时候，缓冲区可能再次空出。现在，我们需要将数据从<code>buf-&gt;data</code> 复制到用户空间。<code>copy_to_user()</code>内核函数就干了此事：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size = min(size, (<span class="keyword">size_t</span>) (buf-&gt;end - buf-&gt;read_ptr));</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(out, buf-&gt;read_ptr, size)) &#123;</span><br><span class="line">    result = -EFAULT;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户空间指针错误，那么调用可能会失败；如果发生了此事，我们就返回<code>-EFAULT</code>。记住，不要相信任何来自内核外的事物！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    buf-&gt;read_ptr += size;</span><br><span class="line">    result = size;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使数据在任意块可读，需要进行简单运算。该方法返回读入的字节数，或者一个错误代码。</p>
<p>写方法更简短。首先，我们检查缓冲区是否有足够的空间，然后我们使用<code>copy_from_userspace()</code>函数来获取数据。再然后<code>read_ptr</code>和结束指针会被重置，并且反转存储缓冲区内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf-&gt;end = buf-&gt;data + size;</span><br><span class="line">    buf-&gt;read_ptr = buf-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;end &gt; buf-&gt;data)</span><br><span class="line">        reverse_phrase(buf-&gt;data, buf-&gt;end - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这里， <code>reverse_phrase()</code>干了所有吃力的工作。它依赖于<code>reverse_word()</code>函数，该函数相当简短并且标记为内联。这是另外一个常见的优化；但是，你不能过度使用。因为过多的内联会导致内核映像徒然增大。</p>
<p>最后，我们需要唤醒<code>read_queue</code>中等待数据的进程，就跟先前讲过的那样。<code>wake_up_interruptible()</code>就是用来干此事的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wake_up_interruptible(&amp;buf-&gt;read_queue);</span><br></pre></td></tr></table></figure>
<p>耶！你现在已经有了一个内核模块，它至少已经编译成功了。现在，是时候来测试了。</p>
<h2 id="调试内核代码"><a href="#调试内核代码" class="headerlink" title="调试内核代码"></a>调试内核代码</h2><p>或许，内核中最常见的调试方法就是打印。如果你愿意，你可以使用普通的<code>printk()</code>（假定使用<code>KERN_DEBUG</code>日志等级）。然而，那儿还有更好的办法。如果你正在写一个设备驱动，这个设备驱动有它自己的“struct device”，可以使用<code>pr_debug()</code>或者<code>dev_dbg()</code>：它们支持动态调试（dyndbg）特性，并可以根据需要启用或者禁用（请查阅<code>Documentation/dynamic-debug-howto.txt</code>）。对于单纯的开发消息，使用<code>pr_devel()</code>，除非设置了DEBUG，否则什么都不会做。要为我们的模块启用DEBUG，请添加以下行到<code>Makefile</code>中：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS_reverse.o := -DDEBUG</span><br></pre></td></tr></table></figure>
<p>完了之后，使用dmesg来查看<code>pr_debug()</code>或<code>pr_devel()</code>生成的调试信息。 或者，你可以直接发送调试信息到控制台。要想这么干，你可以设置<code>console_loglevel</code>内核变量为8或者更大的值（<code>echo 8 /proc/sys/kernel/printk</code>），或者在高日志等级，如KERN_ERR，来临时打印要查询的调试信息。很自然，在发布代码前，你应该移除这样的调试声明。</p>
<p>注意内核消息出现在控制台，不要在Xterm这样的终端模拟器窗口中去查看；这也是在内核开发时，建议你不在X环境下进行的原因。</p>
<h3 id="惊喜，惊喜！"><a href="#惊喜，惊喜！" class="headerlink" title="惊喜，惊喜！"></a>惊喜，惊喜！</h3><p>编译模块，然后加载进内核：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sudo insmod reverse.ko buffer_size=2048</span><br><span class="line">$ lsmod</span><br><span class="line">reverse 2419 0</span><br><span class="line">$ ls -l /dev/reverse</span><br><span class="line">crw-rw-rw- 1 root root 10, 58 Feb 22 15:53 /dev/reverse</span><br></pre></td></tr></table></figure>
<p>一切似乎就位。现在，要测试模块是否正常工作，我们将写一段小程序来翻转它的第一个命令行参数。<code>main()</code>（再三检查错误）可能看上去像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/reverse"</span>, O_RDWR);</span><br><span class="line">write(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">read(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Read: %s\n"</span>, argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>像这样运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="built_in">test</span> <span class="string">'A quick brown fox jumped over the lazy dog'</span></span><br><span class="line">Read: dog lazy the over jumped fox brown quick A</span><br></pre></td></tr></table></figure>
<p>它工作正常！玩得更逗一点：试试传递单个单词或者单个字母的短语，空的字符串或者是非英语字符串（如果你有这样的键盘布局设置），以及其它任何东西。</p>
<p>现在，让我们让事情变得更好玩一点。我们将创建两个进程，它们共享一个文件描述符（及其内核缓冲区）。其中一个会持续写入字符串到设备，而另一个将读取这些字符串。在下例中，我们使用了<code>fork(2)</code>系统调用，而pthreads也很好用。我也省略打开和关闭设备的代码，并在此检查代码错误（又来了）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *phrase = <span class="string">"A quick brown fox jumped over the lazy dog"</span>;</span><br><span class="line"><span class="keyword">if</span> (fork())</span><br><span class="line">    <span class="comment">/* Parent is the writer */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        write(fd, phrase, len);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* child is the reader */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read(fd, buf, len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Read: %s\n"</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你希望这个程序会输出什么呢？下面就是在我的笔记本上得到的东西：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Read: dog lazy the over jumped fox brown quick A</span><br><span class="line">Read: A kcicq brown fox jumped over the lazy dog</span><br><span class="line">Read: A kciuq nworb xor jumped fox brown quick A</span><br><span class="line">Read: A kciuq nworb xor jumped fox brown quick A</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里发生了什么呢？就像举行了一场比赛。我们认为read和write是原子操作，或者从头到尾一次执行一个指令。然而，内核确实无序并发的，随便就重新调度了<code>reverse_phrase()</code>函数内部某个地方运行着的写入操作的内核部分。如果在写入操作结束前就调度了read()操作呢？就会产生数据不完整的状态。这样的bug非常难以找到。但是，怎样来处理这个问题呢？</p>
<p>基本上，我们需要确保在写方法返回前没有read方法能被执行。如果你曾经编写过一个多线程的应用程序，你可能见过同步原语（锁），如互斥锁或者信号。Linux也有这些，但有些细微的差别。内核代码可以运行进程上下文（用户空间代码的“代表”工作，就像我们使用的方法）和终端上下文（例如，一个IRQ处理线程）。如果你已经在进程上下文中和并且你已经得到了所需的锁，你只需要简单地睡眠和重试直到成功为止。在中断上下文时你不能处于休眠状态，因此代码会在一个循环中运行直到锁可用。关联原语被称为自旋锁，但在我们的环境中，一个简单的互斥锁 —— 在特定时间内只有唯一一个进程能“占有”的对象 —— 就足够了。处于性能方面的考虑，现实的代码可能也会使用读-写信号。</p>
<p>锁总是保护某些数据（在我们的环境中，是一个“struct buffer”实例），而且也常常会把它们嵌入到它们所保护的结构体中。因此，我们添加一个互斥锁（‘struct mutex lock’）到“struct buffer”中。我们也必须用<code>mutex_init()</code>来初始化互斥锁；<code>buffer_alloc</code>是用来处理这件事的好地方。使用互斥锁的代码也必须包含<code>linux/mutex.h</code>。</p>
<p>互斥锁很像交通信号灯 —— 要是司机不看它和不听它的，它就没什么用。因此，在对缓冲区做操作并在操作完成时释放它之前，我们需要更新<code>reverse_read()</code>和<code>reverse_write()</code>来获取互斥锁。让我们来看看read方法 —— write的工作原理相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">reverse_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user * out,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer</span> *<span class="title">buf</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line">    <span class="keyword">if</span> (mutex_lock_interruptible(&amp;buf-&gt;lock)) &#123;</span><br><span class="line">        result = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在函数一开始就获取锁。<code>mutex_lock_interruptible()</code>要么得到互斥锁然后返回，要么让进程睡眠，直到有可用的互斥锁。就像前面一样，<code>_interruptible</code>后缀意味着睡眠可以由信号来中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (buf-&gt;read_ptr == buf-&gt;end) &#123;</span><br><span class="line">    mutex_unlock(&amp;buf-&gt;lock);</span><br><span class="line">    <span class="comment">/* ... wait_event_interruptible() here ... */</span></span><br><span class="line">    <span class="keyword">if</span> (mutex_lock_interruptible(&amp;buf-&gt;lock)) &#123;</span><br><span class="line">        result = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是我们的“等待数据”循环。当获取互斥锁时，或者发生称之为“死锁”的情境时，不应该让进程睡眠。因此，如果没有数据，我们释放互斥锁并调用<code>wait_event_interruptible()</code>。当它返回时，我们重新获取互斥锁并像往常一样继续：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(out, buf-&gt;read_ptr, size)) &#123;</span><br><span class="line">        result = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">out_unlock:</span><br><span class="line">    mutex_unlock(&amp;buf-&gt;lock);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>最后，当函数结束，或者在互斥锁被获取过程中发生错误时，互斥锁被解锁。重新编译模块（别忘了重新加载），然后再次进行测试。现在你应该没发现毁坏的数据了。</p>
<h3 id="接下来是什么？"><a href="#接下来是什么？" class="headerlink" title="接下来是什么？"></a>接下来是什么？</h3><p>现在你已经尝试了一次内核黑客。我们刚刚为你揭开了这个话题的外衣，里面还有更多东西供你探索。我们的第一个模块有意识地写得简单一点，在从中学到的概念在更复杂的环境中也一样。并发、方法表、注册回调函数、使进程睡眠以及唤醒进程，这些都是内核黑客们耳熟能详的东西，而现在你已经看过了它们的运作。或许某天，你的内核代码也将被加入到主线Linux源代码树中 —— 如果真这样，请联系我们！</p>
<p>转载自：<a href="https://linux.cn/article-3251-1.html" target="_blank" rel="noopener">https://linux.cn/article-3251-1.html</a></p>
<p>原文：<a href="http://www.linuxvoice.com/be-a-kernel-hacker/" target="_blank" rel="noopener">http://www.linuxvoice.com/be-a-kernel-hacker</a> </p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/Kernel/" rel="tag"># Kernel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/10/07/《皮囊》《孩子你慢慢来》/" rel="next" title="《皮囊》《孩子你慢慢来》">
                <i class="fa fa-chevron-left"></i> 《皮囊》《孩子你慢慢来》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/10/11/MySQL学习笔记－整理-1/" rel="prev" title="MySQL学习笔记－整理(1)">
                MySQL学习笔记－整理(1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/avatar.jpg" alt="HuberyLee">
            
              <p class="site-author-name" itemprop="name">HuberyLee</p>
              <div class="site-description motion-element" itemprop="description">玩得酷，靠得住，有梦想，爱学习的实力派！</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">124</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://idoubi.cc/" title="http://idoubi.cc/" rel="noopener" target="_blank">艾逗笔</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://chambakari.cn/" title="http://chambakari.cn/" rel="noopener" target="_blank">Bakari's Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/cloud_xiaobai" title="http://blog.csdn.net/cloud_xiaobai" rel="noopener" target="_blank">大帅哥的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#尽可能不要用root身份"><span class="nav-number">1.</span> <span class="nav-text">尽可能不要用root身份</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块的构造"><span class="nav-number">1.1.</span> <span class="nav-text">模块的构造</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么时候不该写内核模块"><span class="nav-number">2.</span> <span class="nav-text">什么时候不该写内核模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导航"><span class="nav-number">3.</span> <span class="nav-text">导航</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#混杂设备"><span class="nav-number">3.1.</span> <span class="nav-text">混杂设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭和打开"><span class="nav-number">3.2.</span> <span class="nav-text">关闭和打开</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学习如何读和写"><span class="nav-number">3.3.</span> <span class="nav-text">学习如何读和写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试内核代码"><span class="nav-number">4.</span> <span class="nav-text">调试内核代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#惊喜，惊喜！"><span class="nav-number">4.1.</span> <span class="nav-text">惊喜，惊喜！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接下来是什么？"><span class="nav-number">4.2.</span> <span class="nav-text">接下来是什么？</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuberyLee</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + '3fYbb2sl0ejTHebEh35beUUF-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': '3fYbb2sl0ejTHebEh35beUUF-gzGzoHsz',
                'X-LC-Key': 'a4WT2UMeXclsnQomVwfGIYGJ',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  
  

  
  

  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
