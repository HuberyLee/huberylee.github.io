<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=7.0.1">


  <link rel="mask-icon" href="/favicon.ico?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="在理解 HashMap、ConcurrentHashMap 等实现原理之前，我们首先必须了解 哈希表 的相关知识。简单来讲，哈希表就是利用某种映射关系 $key \to h(key)$，将关键字 $key$ 映射到内存单元中的某个地址 $h(key)$，并在该地址中存储对应数据的这样一个过程，其中决定映射关系的函数 $h(x)$ 被称为哈希函数。在理想情况下，每一个 $key$ 对应一个独立的内存">
<meta name="keywords" content="HashMap,哈希表,红黑树,负载因子,ConcurrentHashMap">
<meta property="og:type" content="article">
<meta property="og:title" content="Java容器之HashMap实现原理">
<meta property="og:url" content="https://www.huberylee.com/2017/03/12/Java容器之HashMap实现原理/index.html">
<meta property="og:site_name" content="HuberyLee">
<meta property="og:description" content="在理解 HashMap、ConcurrentHashMap 等实现原理之前，我们首先必须了解 哈希表 的相关知识。简单来讲，哈希表就是利用某种映射关系 $key \to h(key)$，将关键字 $key$ 映射到内存单元中的某个地址 $h(key)$，并在该地址中存储对应数据的这样一个过程，其中决定映射关系的函数 $h(x)$ 被称为哈希函数。在理想情况下，每一个 $key$ 对应一个独立的内存">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.huberylee.com/images/2017-03-12/hash_link.png">
<meta property="og:image" content="https://www.huberylee.com/images/2017-03-12/diagram.png">
<meta property="og:image" content="https://www.huberylee.com/images/2017-03-12/example.png">
<meta property="og:updated_time" content="2018-01-07T02:54:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java容器之HashMap实现原理">
<meta name="twitter:description" content="在理解 HashMap、ConcurrentHashMap 等实现原理之前，我们首先必须了解 哈希表 的相关知识。简单来讲，哈希表就是利用某种映射关系 $key \to h(key)$，将关键字 $key$ 映射到内存单元中的某个地址 $h(key)$，并在该地址中存储对应数据的这样一个过程，其中决定映射关系的函数 $h(x)$ 被称为哈希函数。在理想情况下，每一个 $key$ 对应一个独立的内存">
<meta name="twitter:image" content="https://www.huberylee.com/images/2017-03-12/hash_link.png">






  <link rel="canonical" href="https://www.huberylee.com/2017/03/12/Java容器之HashMap实现原理/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Java容器之HashMap实现原理 | HuberyLee</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HuberyLee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    

    

    <a href="/" rel="section">首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    

    

    <a href="/archives/" rel="section">归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-photography">

    
    
    

    

    <a href="https://huberylee.tuchong.com" rel="noopener" target="_blank">摄影</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    

    

    <a href="/about/" rel="section">关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.huberylee.com/2017/03/12/Java容器之HashMap实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HuberyLee">
      <meta itemprop="description" content="玩得酷，靠得住，有梦想，爱学习的实力派！">
      <meta itemprop="image" content="/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HuberyLee">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java容器之HashMap实现原理

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-03-12 09:17:12" itemprop="dateCreated datePublished" datetime="2017-03-12T09:17:12+08:00">2017-03-12</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开发/" itemprop="url" rel="index"><span itemprop="name">开发</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开发/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          
            <span id="/2017/03/12/Java容器之HashMap实现原理/" class="leancloud_visitors" data-flag-title="Java容器之HashMap实现原理">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在理解 HashMap、ConcurrentHashMap 等实现原理之前，我们首先必须了解 <a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">哈希表</a> 的相关知识。简单来讲，哈希表就是利用某种映射关系 $key \to h(key)$，将关键字 $key$ 映射到内存单元中的某个地址 $h(key)$，并在该地址中存储对应数据的这样一个过程，其中决定映射关系的函数 $h(x)$ 被称为<strong>哈希函数</strong>。在理想情况下，每一个 $key$ 对应一个独立的内存地址 $h(key)$，各个 $h(key)$ 之间互不冲突，如果不考虑空间资源的利用率，我们可以在很大的内存空间内只存极少的数据，那么这种情况是可能的。</p>
<a id="more"></a>
<p>但是在实际情况中，我们希望在有限的连续空间内存储尽可能多的数据，这就不得不去找一个近乎完美的哈希函数，将数据尽可能均匀的散列到有限的内存空间，这个过程中不可避免的将不同的 $key$ 值映射到相同的内存地址（<strong>哈希冲突</strong>），此时，我们需要将发生冲突的 $key$ 根据某种新的规则 $f(x)$ 重新映射到不同的内存空间 $f(key)$，这种解决冲突时所使用的映射规则称为<strong>哈希冲突函数</strong>。重映射后的内存地址有可能还是冲突的，那么我们就需要使用另外一种映射规则 $f_i(x)$ 重新映射，这个过程将一直持续下去，直到不存在哈希冲突为止，所以，解决哈希冲突的函数可能不止一个，而是一组。显然，内存空间的利用率越高，哈希冲突发生的可能性就越大，而过多的重映射会导致插入和查找的效率低下，那么我们就需要兼顾内存空间的利用率和哈希冲突的发生。这里，我们使用<strong>负载因子 $\alpha$</strong>（load factor，哈希表中存储元素的个数 $n$ 与哈希表长度 $m$ 的比值，即 $\alpha=n/m$）来表示内存空间额利用率，通常使 $\alpha$ 控制在 $0.6\sim0.9$范围内。可以发现，哈希冲突与哈希函数、哈希冲突函数、负载因子均有关系。下面我们来看看如何设计哈希函数以及在发生哈希冲突后如何解决。</p>
<h2 id="哈希函数构造方法"><a href="#哈希函数构造方法" class="headerlink" title="哈希函数构造方法"></a>哈希函数构造方法</h2><p>哈希函数的目的在于使 $n$ 个数据元素尽可能均匀的映射到 $m$ 个内存单元中，使得哈希冲突发生的概率尽可能小，进而提高插入和查找的时间效率。下面一起来学习一下常见的整数类型关键字的哈希函数设计方法。</p>
<ul>
<li><strong>除留余数法</strong>：除留余数法是使用数据元素关键字 $key$ 除以哈希表长度 $m$ 所得的余数作为哈希地址的方法：</li>
</ul>
<p>$$<br>h(key) = key \bmod m<br>$$</p>
<p>这种方法的关键在于选好哈希表的长度，使得每一个关键字 $key$ 通过该函数映射到 $m$ 个内存单元的任意地址上的概率相等，从而尽可能的减少哈希冲突的发生。一般情况下，除留余数法的哈希表长度 $m$ 取素数时的效果最好，有前面提到的 $0.6 \leq n \leq 0.9$ 可知，$m$ 取 $1.1n \sim 1.7n$ 之间的一个素数。</p>
<ul>
<li><strong>直接定址法</strong>：直接定制法采用元素关键字 $key$ 直接加上一个指定常量 $A$ 的所得结果作为哈希地址：</li>
</ul>
<p>$$<br>h(key) = key\ + \ A<br>$$</p>
<p>这种方法不可能发生哈希冲突（元素关键唯一），但是如果 $key$ 值分布不均，或者间隔很大，可能会造成内存空间的极大浪费。</p>
<ul>
<li><strong>分析法</strong>：分析法没有固定的哈希函数，它是通过分析给定数据关键字之间存在的某种关系（比如说某些数据序列出现的比较均匀）来确定哈希函数，这种方法只适合于所有关键字值已知的情况下。</li>
</ul>
<h2 id="哈希冲突解决办法"><a href="#哈希冲突解决办法" class="headerlink" title="哈希冲突解决办法"></a>哈希冲突解决办法</h2><ul>
<li><strong>线性探查法</strong>：线性探查法是从发生冲突的地址 $d_i$ 开始，依次探查 $d_i$ 的下一个地址是否可用，直到找到一个可用地址为止：</li>
</ul>
<p>$$<br>\begin{cases}<br>d_0 &amp;= h(key) \\<br>d_{i+1} &amp;= (d_i + 1) \bmod m, &emsp;&emsp; 1 \leq i \leq m-1<br>\end{cases}<br>$$</p>
<p>$m-1$ 为哈希表最后一个位置，下一个该查找的为止为首地址 $0$。线性探查法容易产生堆积问题，即一个产生冲突的元素通过线性探查找的新位置本来所对应的元素也会产生冲突，从而导致该过程持续累计发生。</p>
<ul>
<li><strong>平方探查法</strong>：平方探查法跟线性探查法类似，只不过每次增加的不是 1 ，而是 $2^i$：</li>
</ul>
<p>$$<br>\begin{cases}<br>d_0 &amp;= h(key) \\<br>d_{i+1} &amp;= (d_i + 2^i) \bmod m, &emsp;&emsp; 1 \leq i \leq m-1<br>\end{cases}<br>$$</p>
<p>即：如果 $d_{i+1}$ 在地址映射时发生冲突，那么会依次探查 $(d_i + 2^0) \bmod m$、$(d_i + 2^1) \bmod m$、$(d_i + 2^2) \bmod m$、 ……，直到找到一个可用的内存空间为止。</p>
<ul>
<li><strong>伪随机数法</strong>：伪随机数法是在发生哈希冲突后采用发生冲突的地址 $d_i$ 加一个随机数 $R$ 的方法得到一个新的内存地址：</li>
</ul>
<p>$$<br>\begin{cases}<br>d_0 &amp;= h(key) \\<br>d_{i+1} &amp;= (d_i + R) \bmod m, &emsp;&emsp; 1 \leq i \leq m-1<br>\end{cases}<br>$$</p>
<p>随机数的产生有很多方式，这个可以根据需求自己来定。</p>
<div class="note info">
            <p><em>Tips</em>：可以发现，无论是<strong>线性探查法</strong>、<strong>平方探查法</strong>还是<strong>伪随机数法</strong>，均是采用在发生冲突的地址 $d_i$ 的基础上加一个数字来得到一个新的内存地址，它们之间根据所增加的数字是线性递增、平方数递增还是随机递增得以区分，冲突后的地址可以根据哈希冲突函数直接计算得到。在根据 $key$ 进行数据查找时，首先利用哈希函数 $h(x)$ 去对应地址查找，若对应地址内所存数据与目标值不匹配，则利用哈希冲突函数去新的内存地址查找，直到查找过程结束。</p>
          </div>
<ul>
<li><strong>链表法</strong>：与上述三种解决哈希冲突的方法不同，链表法采用链表存储发生冲突的元素数据，根据是否为发生冲突的元素建立统一的链表还是每一个冲突地址建立一条链表分为两种形式。</li>
</ul>
<p>假设给定数据 $\left\{31, 19, 11, 23, 45, 32, 8, 67, 78, 73\right\}$，采用 $h(key) = key \bmod m$ 作为哈希函数，哈希表长度为 11，则链表法的两种不同方式分别为：</p>
<p><img src="/images/2017-03-12/hash_link.png" alt></p>
<p>了解了哈希表的基本知识后，现在我们来看看 Java 中 HashMap 的实现原理。</p>
<h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p>Java 中 HashMap 采用链表法中的第一种方式处理哈希冲突，不过在具体的实现上有所不同，下面我们将通过阅读 JDK 源码的方式来一步步了解 HashMap 的具体实现。我们首先来看一看 JDK1.8 源码中对 HashMap 的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span><br><span class="line">* implementation provides all of the optional map operations, and permits</span><br><span class="line">* &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span><br><span class="line">* class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span><br><span class="line">* unsynchronized and permits nulls.)  This class makes no guarantees as to</span><br><span class="line">* the order of the map; in particular, it does not guarantee that the order</span><br><span class="line">* will remain constant over time.</span><br></pre></td></tr></table></figure>
<p>意思大概是说 <tt>HashMap</tt> 是基于哈希表的 <tt>Map</tt> 接口实现，它提供所有的 <tt>Map</tt> 可选操作， 并且允许多个 <tt>null</tt> 值和一个 <tt>null</tt> 键。<tt>HashMap</tt> 和 <tt>HashTable</tt> 大致相同，除了它是非同步的和它允许 <tt>null</tt> 值和 <tt>null</tt> 键外。这个类对元素的插入顺序没有保证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters that affect its</span><br><span class="line">* performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load factor&lt;/i&gt;.  The</span><br><span class="line">* &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash table, and the initial</span><br><span class="line">* capacity is simply the capacity at the time the hash table is created.  The</span><br><span class="line">* &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash table is allowed to</span><br><span class="line">* get before its capacity is automatically increased.  When the number of</span><br><span class="line">* entries in the hash table exceeds the product of the load factor and the</span><br><span class="line">* current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt; (that is, internal data</span><br><span class="line">* structures are rebuilt) so that the hash table has approximately twice the</span><br><span class="line">* number of buckets.</span><br><span class="line">*</span><br><span class="line">* &lt;p&gt;As a general rule, the default load factor (.75) offers a good</span><br><span class="line">* tradeoff between time and space costs.  Higher values decrease the</span><br><span class="line">* space overhead but increase the lookup cost (reflected in most of</span><br><span class="line">* the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span><br><span class="line">* &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span><br><span class="line">* the map and its load factor should be taken into account when</span><br><span class="line">* setting its initial capacity, so as to minimize the number of</span><br><span class="line">* rehash operations.  If the initial capacity is greater than the</span><br><span class="line">* maximum number of entries divided by the load factor, no rehash</span><br><span class="line">* operations will ever occur.</span><br></pre></td></tr></table></figure>
<p>一个 <tt>HashMap</tt> 实例有两个影响它性能的参数：<i>initial capacity</i> 和 <i>load factor</i>，其中 <i>initial capacity</i> 代表的是哈希表中桶的数量，也就是我们所说的数组的大小，它决定着哈希表创建时数组的初始长度；<i>load factor</i> 则表示哈希表可以装多满，也就是我们所说的负载因子（$\alpha=n/m$），当实际负载量达到负载因子时，哈希表会自动增长为原来的两倍。通常，负载因子取 0.75 时可以在时间和空间开销间达到一个很好的平衡，更高的值虽然减小了空间的开销，却增加了查找的时间，影响 <tt>HashMap</tt> 的大部分操作，包括 <tt>get</tt> 和 <tt>put</tt> 操作。</p>
<p>下面是一张 <tt>HashMap</tt> 类图表，主要包括 <tt>HashMap</tt> 的内部类及相关属性，可以看到 <tt>HashMap</tt> 的属性主要包括 <tt>Node</tt> 类型的数组 <i>table</i>、负载因子 <i>load factor</i>、临界值 <i>threshold</i>等。</p>
<p><img src="/images/2017-03-12/diagram.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><tt>HashMap</tt> 继承 <tt>AbstractMap</tt> 类并实现了 <tt>Map</tt>、 <tt>Cloneable</tt>、 <tt>Serializable</tt> 接口，下面是类中定义的一些常量，具体含义请看代码中注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认 table 数组长度为 16，必须是 2 的 n 次方，初始化时可以指定 table 数组长度，</span></span><br><span class="line"><span class="comment"> * 若指定的数组长度不为 2 的 n 次方，将会自动转化为大于指定长度的最小的一个 2 的 n </span></span><br><span class="line"><span class="comment"> * 次方值作为初始数组长度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组最大的长度为 2 的 30 次方，超过这个长度后数组将不再扩容（每次扩容后数组大小</span></span><br><span class="line"><span class="comment"> * 均为扩容前数组大小的 2 倍，已存在元素进行重散列）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认负载因子为 0.75</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列转化为红黑树的长度临界值，当队列长度大于等于 8 时将被转化为红黑树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树转化为队列的节点个数临界值，当红黑树中节点个数小于等于 6 时红黑树将被转化为队列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将队列转化为红黑树除了满足队列长度大于等于 8 这个条件外，还得满足 table 数组的大小</span></span><br><span class="line"><span class="comment"> * 至少为 64，否则即使队列长度超过了 8，也只会进行数组的扩容，而不会将数组转化为红黑</span></span><br><span class="line"><span class="comment"> * 树，具体的操作请参阅 putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="comment"> * boolean evict) 方法调用 treeifyBin(Node&lt;K,V&gt;[] tab, int hash) 方法这一过程。</span></span><br><span class="line"><span class="comment"> * 这个值至少为 4 * TREEIFY_THRESHOLD，以避免扩容与树化之间的冲突。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>了解了这些定义的常量及其作用之后，我们大概就知道了 <tt>HashMap</tt> 的设计理念及各种操作中应该注意的事项，下面我们来看看具体的各种实现。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JDK1.8 中 <tt>HashMap</tt> 类提供了这4种构造方法，默认 <i>table</i> 数组大小为 16、负载因子为 0.75，但是构造函数中并没有直接初始化 <i>table</i>。在 <tt>HashMap</tt> 中，<i>table</i> 数组的初始化采用延迟加载的方式，只有在第一次使用 <tt>put</tt> 方法时才会调用 <tt>resize</tt> 方法进行初始化，详情请参阅后文对 <tt>put</tt>、<tt>resize</tt> 方法的实现分析。这里我们来看一下如果初始化时指定数组大小时的具体操作。<tt>HashMap</tt> 中，<tt>public HashMap(int initialCapacity, float loadFactor)</tt>和<tt>public HashMap(int initialCapacity)</tt> 这两个构造函数可以指定初始化时 <i>table</i> 数组大小，其中<tt>public HashMap(int initialCapacity)</tt> 构造函数最终还是通过使用默认负载因子来调用 <tt>public HashMap(int initialCapacity, float loadFactor)</tt> 构造函数，数组最终的大小也是通过 <tt>static final int tableSizeFor(int cap)</tt> 方法确定，我们可以看到，初始化时指定的数组大小若是 2 的 n 次方，则实际数组大小就为指定的数组大小，否则实际数组的大小将为大于指定数组大小的一个最小的 2 的 n 次方值，例如指定数组大小为 10， 则通过位运算后得出的数组实际大小为 16，这与我们前面介绍 <tt>HashMap</tt> 类常量时的分析一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过使用默认负载因子来调用 public HashMap(int initialCapacity, float loadFactor) </span></span><br><span class="line"><span class="comment"> * 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash()函数"></a>hash()函数</h3><p>HashMap 中哈希函数是通过 key 键值类型自带的哈希函数得到哈希值 h，然后将 h 与 h 的高16位异或得到 hash 值。确定元素在 table 中的 index 时，根据 (table.length - 1) &amp; hash 得到，由于 table 的长度为 2 的 n 次方，所以减一后类似掩码（00001000 - 1 = 00000111）。其实，利用 key 键值类型自带的哈希函数得到的 hash 值也可以直接用，为什么还要进行接下来的操作呢？原因是带符号的int表值范围从-2147483648到2147483648，前后加起来大概40亿的映射空间，在这个空间内，得到的 hash 值是可以很好地均匀分布的，但是，我们用的 HashMap 远小于这个大小，默认的只有 16，所以会根据 HashMap 中的数组长度进行取模操作，这里的取模操作就是 hash &amp; (table.length - 1)，但是，这样一来，相当于就只有后几位参与运算，发生冲突的可能性比较高，所以这里加入了高16位参与计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h3><p>resize() 方法用来初始化 table，或者是将原 table 的容量扩为 2 倍，并对已有的元素进行扩容后的重散列操作。若超过最大容量，则保持不变。由于 HashMap 在初始化时 table 的大小为 2 的 n 次方，扩容时直接扩为原来的 2 倍，所以重散列后原有元素要么在原位置，要么在原位置加 2 的 n 次方的新位置。当处理同一个桶中的元素时，resize 方法中采用两个链表分别保存这两种情况的元素，在原位置的采用 low 链表，原位置 + 2 的 n 次的采用 high 链表。具体的操作实现请看代码注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果原 table 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果超过允许的数组最大长度（2 的 30 次方），则不再扩容，直接返回原数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，如果扩容为原来的 2 倍后没有超过允许的最大长度 且 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果原 table 为空， 但 threshold 设有值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 如果原 table 为空，threshold 为0，则根据默认初始化能力和负载因子为新的 HashMap 设置初始化能力和阈值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果原 table 不为空，则需要对原有的数据进行重散列</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 如果 table[j] 中有元素，则需进行下一步操作</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放该节点</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 同一个位置未发生散列冲突，即 next 为空，则直接重散列该元素到新的 HashMap 中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 该桶中是一颗红黑树，则通过红黑树的 split 方法处理</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// 链表的情况下直接遍历链表依次处理每一个节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 由于 HashMap 在初始化时 table 的大小为 2 的 n 次方，</span></span><br><span class="line">                    <span class="comment">// 扩容时直接扩为原来的 2 倍，所以重散列后原有元素要么在原位置，</span></span><br><span class="line">                    <span class="comment">// 要么在原位置 + 2 的 n 次方的位置，</span></span><br><span class="line">                    <span class="comment">// 这里采用采用两个链表分别保存这两种情况的元素，</span></span><br><span class="line">                    <span class="comment">// 在原位置的采用 low 链表，原位置 + 2 的 n 次的采用 high 链表 </span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// low 链表仍在原位置</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// high 链表在原位置 + 2 的 n 次的位置</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><p>put() 方法将给定的 key→valuekey→value 映射关系存入 HashMap 中，如果该 key 在 HashMap 中已存在，则替换其对应的 value 值，并返回替换前的 value 值；否则，存入映射关系后返回 null。注意，由于 HashMap 中允许存在 null 值，所以返回 null 值并不能说明该 key 值原来不在 HashMap 中，可能是存在 key→nullkey→null 映射关系。</p>
<p>新数据的存入，实际上是通过 putVal() 函数完成的。在 putVal() 函数中，首先会判断 HashMap 的状态，是否为 null 或者是大小为0。如果是，则说明是第一次向 HashMap 中存入数据，需要通过 resize() 方法初始化 HashMap，这也是 HashMap 延迟初始化的体现。接下来，根据 key 值计算 hash 值，如果 hash 值对应的位置没有存入元素，则直接存入新的数据；否则，分为两种情况：1、key 已存在。这个时候会根据 onlyIfAbsent 参数决定是否要替换其对应的 value 值；2、发生 hash 冲突。在这种情况下，如果该 hash 地址后的元素以红黑树的方式存储，则直接调用 putTreeVal() 方法加入新的节点元素；如果是以链表的方式存储，则直接将新的元素加入链表末尾并根据元素的个数决定是否要将量表转化为红黑树。所有的操作结束后，根据 HashMap 元素个数判断是否需要 resize 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// HashMap 延迟初始化体现</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 未发生 hash 冲突，直接存入新的元素</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// key 已经存在，先保存节点引用，后面根据 onlyIfAbsent 决定是否要替换其对应的 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 以红黑树形式存储，直接调用红黑树对应的加入新节点的方法添加新的元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 以链表的形式存储，直接在链表末尾加入新的元素并根据链表长度判断是否需要将链表转化为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表是否需要转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key 值已存在时，根据 onlyIfAbsent 参数判断是否需要替换其对应的 value 值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 根据 size 判断是否需要 resize 操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><p>get(Object key) 方法返回该 key 所关联的 value 值，如果 HashMap 中不存在该 key→valuekey→value 的映射关系，则返回 null。值得注意的是，由于 Java 中 HashMap 可以存放 null 值，所以返回 null 值时并不能说明 HashMap 中一定不存在 key→valuekey→value 的映射关系，有可能是该 key 对应的值就是 null。</p>
<p>在查找 key 对应的值时，与前面介绍的解决哈希冲突的方式相对应。首先判断 hash 地址对应的元素是否为要查找的元素，满足条件则直接返回（未发生 hash 冲突）；否则，在对应的链表/红黑树中查找对应元素（前面有讲过，当链表的长度超过8且数组长度超过64时，链表会被转化为红黑树）。这两种数据结构的查找方法相信大家都很熟悉，不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment"> * distinguish these two cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查直接 hash 得到的节点，该节点一定是数组中对应的某一元素</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果发生冲突的节点以红黑树的方式存放，则获取对应的树的节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则，直接遍历链表即可</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 Java 中 HashMap 的实现原理及基本操作的实现分析，了解哈希表的基本知识后，结合 Java 中 HashMap 的实现原理，再去看起源码，很简单。下面给一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lihui on 2017/4/28.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, Integer&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        linkedHashMap.put(<span class="string">"语文"</span>, <span class="number">100</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"数学"</span>, <span class="number">101</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"外语"</span>, <span class="number">102</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"物理"</span>, <span class="number">103</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"化学"</span>, <span class="number">104</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"生物"</span>, <span class="number">105</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"地理"</span>, <span class="number">106</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"算法"</span>, <span class="number">107</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"测试"</span>, <span class="number">108</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">"开发"</span>, <span class="number">109</span>);</span><br><span class="line"></span><br><span class="line">        linkedHashMap.put(<span class="string">"数学"</span>, <span class="number">115</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : linkedHashMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"："</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note default">
            <p>输出结果为:<br>语文：100<br>数学：115<br>外语：102<br>物理：103<br>化学：104<br>生物：105<br>地理：106<br>算法：107<br>测试：108<br>开发：109</p>
          </div>
<p>可以看到，输出元素的顺序与加入的顺序不一致并且有2个元素发生哈希冲突，它们以链表的形式存储：</p>
<p><img src="/images/2017-03-12/example.png" alt></p>
<p>总结：</p>
<ul>
<li>Java 中 HashMap 采用 数组 + 链表 + 红黑树 构造；</li>
<li>Java 中 HashMap 数组默认大小为 16，负载因子为 0.75，新建 HashMap 时并不是直接初始化数组，而是在第一次添加数组的时候进行数组的初始化工作，即采用延迟初始化的策略；</li>
<li>数组长度必须是 2 的 n 次方，初始化时可以指定 table 数组长度，若指定的数组长度不为 2 的 n 次方，将会自动转化为大于指定长度的最小的一个 2 的 n 次方值作为初始数组长度；</li>
<li>Java 中每一次对数组扩容时都会将其扩为原来的两倍，由于 table 本来的长度就是 2 的 n 次方，所以扩容后，已有的元素重 hash 后要么在原来的位置，要么在原位置偏移 2 的 n 次方；</li>
<li>当链表长度大于等于8并且数组长度大于等于64时，链表将会被转化为红黑树；当红黑树中节点个数小于6时将会被转化为链表。</li>
</ul>
<p>参考：</p>
<p><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a><br><a href="http://blog.jrwang.me/2016/java-collections-hashmap/" target="_blank" rel="noopener">Java 容器源码分析之 HashMap</a><br><a href="http://www.jianshu.com/p/249809a33ef6" target="_blank" rel="noopener">HashMap工作原理深入探讨</a><br><a href="https://www.zhihu.com/question/20733617" target="_blank" rel="noopener">JDK 源码中 HashMap 的 hash 方法原理是什么？</a></p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          
            <a href="/tags/哈希表/" rel="tag"># 哈希表</a>
          
            <a href="/tags/红黑树/" rel="tag"># 红黑树</a>
          
            <a href="/tags/负载因子/" rel="tag"># 负载因子</a>
          
            <a href="/tags/ConcurrentHashMap/" rel="tag"># ConcurrentHashMap</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/13/Java中String对象创建过程探究/" rel="next" title="Java中String对象创建过程探究">
                <i class="fa fa-chevron-left"></i> Java中String对象创建过程探究
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/31/Java容器之LinkedHashMap实现原理/" rel="prev" title="Java容器之LinkedHashMap实现原理">
                Java容器之LinkedHashMap实现原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/avatar.jpg" alt="HuberyLee">
            
              <p class="site-author-name" itemprop="name">HuberyLee</p>
              <div class="site-description motion-element" itemprop="description">玩得酷，靠得住，有梦想，爱学习的实力派！</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">124</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://idoubi.cc/" title="http://idoubi.cc/" rel="noopener" target="_blank">艾逗笔</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://chambakari.cn/" title="http://chambakari.cn/" rel="noopener" target="_blank">Bakari's Blog</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.csdn.net/cloud_xiaobai" title="http://blog.csdn.net/cloud_xiaobai" rel="noopener" target="_blank">大帅哥的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希函数构造方法"><span class="nav-number">1.</span> <span class="nav-text">哈希函数构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希冲突解决办法"><span class="nav-number">2.</span> <span class="nav-text">哈希冲突解决办法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap实现原理"><span class="nav-number">3.</span> <span class="nav-text">HashMap实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">3.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash-函数"><span class="nav-number">3.2.</span> <span class="nav-text">hash()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resize-方法"><span class="nav-number">3.3.</span> <span class="nav-text">resize()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-方法"><span class="nav-number">3.4.</span> <span class="nav-text">put()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-方法"><span class="nav-number">3.5.</span> <span class="nav-text">get()方法</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuberyLee</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + '3fYbb2sl0ejTHebEh35beUUF-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': '3fYbb2sl0ejTHebEh35beUUF-gzGzoHsz',
                'X-LC-Key': 'a4WT2UMeXclsnQomVwfGIYGJ',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  
  

  
  

  


  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
